<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cycle History</title>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body { font-family: 'Segoe UI', sans-serif; background: #fffafc; padding: 1em; }
  h1, h2, h3 { text-align: center; }
  .nav-button {
    display: block; margin: 1em auto; background: #c4d7b2;
    color: white; padding: 0.6em 1.2em; border-radius: 20px;
    text-align: center; text-decoration: none; max-width: 250px;
  }
  .legend {
    display: flex; flex-wrap: wrap; gap: 0.5em;
    justify-content: center; margin-bottom: 1em;
  }
  .legend span {
    display: inline-block; padding: 0.4em 0.8em;
    border-radius: 5px; font-size: 0.75em;
  }
  .calendar-nav {
    display: flex; justify-content: center; gap: 1em; margin: 0.5em 0;
  }
  .calendar-grid {
    display: grid; grid-template-columns: repeat(7, 1fr);
    gap: 5px; margin-bottom: 1.5em;
  }
  .weekday { font-weight: bold; text-align: center; }
  .day-box {
    padding: 0.6em 0;
    border-radius: 6px;
    background: #f0f0f0;
    text-align: center;
    font-size: 0.85em;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    min-height: 3.5em;
    position: relative;
  }
  .deep-red { background: #e76f8a !important; color: white !important; }
  .red { background: #f6b1b7 !important; }
  .blue { background: #b7d7f6 !important; }
  .bold-blue { background: #5f9ed1 !important; color: white !important; }
  .green { background: #c8e6c9 !important; }
  .chart-container {
    margin: 2em auto; max-width: 900px;
  }
  table {
    width: 100%; border-collapse: collapse; margin: 1em 0; font-size: 0.95em;
  }
  th, td {
    padding: 0.5em; border: 1px solid #ccc; text-align: center;
  }
  th {
    background: #eeb7c2; color: white;
  }
  .day-box span {
    font-size: 1.1em;
    display: block;
    opacity: 0.8;
    line-height: 1;
  }
  .bbt-nav-buttons {
    text-align: center;
    margin: 1em 0;
  }
  .bbt-nav-buttons button {
    margin: 0 0.5em;
    padding: 0.5em 1em;
    font-size: 1em;
    cursor: pointer;
  }
</style>
</head>
<body>

<h1>Cycle History</h1>
<a class="nav-button" href="index.html">‚Üê Back to Home</a>

<h2>Cycle Averages</h2>
<table>
<thead>
  <tr>
    <th>Avg. Cycle Length</th>
    <th>Avg. Luteal Phase</th>
    <th>Avg. Period Length</th>
    <th>Avg. Sex Entries / Cycle</th>
  </tr>
</thead>
<tbody><tr id="averagesRow"><td>‚Äì</td><td>‚Äì</td><td>‚Äì</td><td>‚Äì</td></tr></tbody>
</table>

<div class="legend">
  <span style="background:#e76f8a; color:white;">Day 1 Period</span>
  <span style="background:#f6b1b7;">Period</span>
  <span style="background:#b7d7f6;">Fertile (Flashing)</span>
  <span style="background:#5f9ed1; color:white;">Ovulation (Solid)</span>
  <span style="background:#c8e6c9;">Post Ovulation</span>
  <span style="background:#fff0f5;">üíñ Sex</span>
  <span style="background:#fff0f5;">üòñ Cramps</span>
  <span style="background:#fff0f5;">üîª Spotting</span>
  <span style="background:#fff0f5;">üß† Mood</span>
  <span style="background:#fff0f5;">üå°Ô∏è BBT</span>
  <span style="background:#fff0f5;">ü´∂ Breast Changes</span>
  <span style="background:#fff0f5;">ü´É Digestive</span>
</div>

<div id="predictionBanner" style="text-align:center; margin-bottom: 1em; font-weight: bold;"></div>

<div class="calendar-nav">
  <button onclick="changeMonth(-1)">‚óÄ</button>
  <span id="monthLabel"></span>
  <button onclick="changeMonth(1)">‚ñ∂</button>
</div>
<div style="text-align:center; margin-bottom:1em; font-weight:bold;">
  <span>Predictions: </span>
  <span style="color:#F44336;">üî¥ Period Days</span>
  <span style="color:#4CAF50;">üü¢ Fertile Window</span> | 
  <span style="color:#FFC107;">üü° Ovulation Day</span> | 
</div>
<div class="calendar-grid" id="calendarWeekdays"></div>
<div class="calendar-grid" id="calendarGrid"></div>

<div class="chart-container">
  <h2>BBT Chart</h2>
  <div class="bbt-nav-buttons">
    <button id="prevCycleBtn">‚Üê Previous Cycle</button>
    <button id="nextCycleBtn">Next Cycle ‚Üí</button>
  </div>
  <canvas id="bbtChart"></canvas>
</div>
<div class="chart-container">
  <h2>CM Pattern</h2>
  <canvas id="cmChart"></canvas>
</div>
<div class="chart-container">
  <h2>Average Symptoms</h2>
  <canvas id="symptomsChart"></canvas>
</div>
<div class="chart-container">
  <h2>Mood Timeline</h2>
  <canvas id="moodChart"></canvas>
</div>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyByvnVx2aZEldUfqS2c6VNC6UJRIOPvGws",
  authDomain: "fertility-tracker-c35ff.firebaseapp.com",
  projectId: "fertility-tracker-c35ff"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();

let allEntries = [];
let viewMonth = new Date().getMonth();
let viewYear = new Date().getFullYear();

let avgLutealLength = null;
let avgOvulationDay = null;
let avgCycleLength = null;
let avgPeriodLength = null;

let cycles = [];
let currentCycleIndex = 0; // Tracks which cycle BBT graph shows

let bbtChartInstance;

auth.onAuthStateChanged(async (user) => {
  if (!user) {
    window.location.href = "index.html";
    return;
  }
  await run();
});

function uniqueDays(entries) {
  const days = new Set();
  entries.forEach(e => {
    const day = new Date(e.entryDate).toISOString().slice(0,10);
    days.add(day);
  });
  return Array.from(days);
}

function groupCycles(entries) {
  const cyclesLocal = [];
  let currentCycle = [];

  for (const e of entries) {
    if ((e.phase || '').toLowerCase() === 'day1-period') {
      if (currentCycle.length) cyclesLocal.push([...currentCycle]);
      currentCycle = [];
    }
    currentCycle.push(e);
  }

  // Include last cycle only if completed (has solid face and last entry > 4 days ago)
  const lastCycle = [...currentCycle];
  const hasSolidFace = lastCycle.some(e => (e.opk || '').toLowerCase() === 'solid face');
  const lastDate = new Date(lastCycle.at(-1)?.entryDate || 0);
  const daysSinceLastEntry = (new Date() - lastDate) / 86400000;

  if (lastCycle.length > 3 && hasSolidFace && daysSinceLastEntry > 4) {
    cyclesLocal.push(lastCycle);
  }

  return cyclesLocal;
}

function calculateAverages(cyclesLocal) {
  const cycleLengths = [];
  const lutealPhases = [];
  const periodLengths = [];
  const ovulationDays = [];
  const sexCounts = [];

  for (const cycle of cyclesLocal) {
    const uniqueCycleDays = uniqueDays(cycle);
    if (uniqueCycleDays.length < 10) continue; // skip short cycles

    const ovIndex = cycle.findIndex(e => (e.opk || '').toLowerCase() === 'solid face');
    if (ovIndex === -1) continue;

    cycleLengths.push(uniqueCycleDays.length);

    // Luteal phase length = unique days after ovulation day
    const ovulationDayISO = new Date(cycle[ovIndex].entryDate).toISOString().slice(0,10);
    const lutealDays = uniqueCycleDays.filter(day => day > ovulationDayISO).length;
    lutealPhases.push(lutealDays);

    // Period length counting unique days with 'day1-period' or 'period' phase
    const periodDays = new Set(cycle.filter(e => ['day1-period','period'].includes((e.phase || '').toLowerCase()))
      .map(e => new Date(e.entryDate).toISOString().slice(0,10)));
    periodLengths.push(periodDays.size);

    // Count unique sex days per cycle
    const sexDays = new Set(cycle.filter(e => (e.sex || '').toLowerCase() === 'yes').map(e => new Date(e.entryDate).toISOString().slice(0,10)));
    sexCounts.push(sexDays.size);

    ovulationDays.push(ovIndex + 1);
  }

  avgCycleLength = cycleLengths.length ? cycleLengths.reduce((a,b) => a+b, 0)/cycleLengths.length : null;
  avgLutealLength = lutealPhases.length ? lutealPhases.reduce((a,b) => a+b, 0)/lutealPhases.length : null;
  avgPeriodLength = periodLengths.length ? periodLengths.reduce((a,b) => a+b, 0)/periodLengths.length : null;
  avgOvulationDay = ovulationDays.length ? ovulationDays.reduce((a,b) => a+b, 0)/ovulationDays.length : null;
  const avgSexFreq = sexCounts.length ? sexCounts.reduce((a,b) => a+b, 0)/sexCounts.length : 0;

  function roundIfNumber(n) { return typeof n === 'number' && !isNaN(n) ? Math.round(n*10)/10 : '‚Äì'; }
  document.getElementById('averagesRow').innerHTML = `
    <td>${roundIfNumber(avgCycleLength)}</td>
    <td>${roundIfNumber(avgLutealLength)}</td>
    <td>${roundIfNumber(avgPeriodLength)}</td>
    <td>${roundIfNumber(avgSexFreq)}</td>
  `;
}

function groupEntriesByDate(entries) {
  return entries.reduce((acc, e) => {
    const dateKey = new Date(e.entryDate).toLocaleDateString('en-CA');
    if (!acc[dateKey]) acc[dateKey] = [];
    acc[dateKey].push(e);
    return acc;
  }, {});
}

// Prediction days generation is kept as is (used by calendar)
function generatePredictionDays() {
  let predictionDays = {};
  const lastDay1 = [...allEntries].reverse().find(e => (e.phase || '').toLowerCase() === 'day1-period');

  if (!lastDay1 || !avgCycleLength || !avgLutealLength) return predictionDays;

  const cycleStart = new Date(lastDay1.entryDate);

  for (let cycleNum = 1; cycleNum <= 3; cycleNum++) {
    const predictedPeriodDate = new Date(cycleStart);
    predictedPeriodDate.setDate(predictedPeriodDate.getDate() + Math.round(avgCycleLength) * cycleNum);

    const ovDate = new Date(predictedPeriodDate);
    ovDate.setDate(ovDate.getDate() - Math.round(avgLutealLength));

    const fertileStart = new Date(ovDate);
    fertileStart.setDate(fertileStart.getDate() - 5);

    for (let i = 0; i <= 4; i++) {
      const d = new Date(fertileStart);
      d.setDate(d.getDate() + i);
      const key = d.toLocaleDateString('en-CA');
      predictionDays[key] = 'üü¢';
    }

    const ovKey = ovDate.toLocaleDateString('en-CA');
    predictionDays[ovKey] = 'üü°';

    const periodLength = Math.round(avgPeriodLength) || 5;
    for (let i = 0; i < periodLength; i++) {
      const periodDay = new Date(predictedPeriodDate);
      periodDay.setDate(periodDay.getDate() + i);
      const key = periodDay.toLocaleDateString('en-CA');
      predictionDays[key] = 'üî¥';
    }
  }
  return predictionDays;
}

function renderCalendar(month, year) {
  const container = document.getElementById("calendarGrid");
  container.innerHTML = "";

  document.getElementById("calendarWeekdays").innerHTML = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun']
    .map(d => `<div class="weekday">${d}</div>`).join('');

  const map = groupEntriesByDate(allEntries);
  const predictionDays = generatePredictionDays();

  const start = new Date(year, month, 1);
  const end = new Date(year, month + 1, 0);
  const offset = (start.getDay() + 6) % 7;

  for (let j = 0; j < offset; j++) {
    container.appendChild(document.createElement("div"));
  }

  for (let d = 1; d <= end.getDate(); d++) {
    const date = new Date(year, month, d);
    const key = date.toLocaleDateString('en-CA');
    const dayEntries = map[key] || [];

    const box = document.createElement("div");
    box.className = "day-box";
    box.textContent = d;

    if (dayEntries.length > 0) {
      const emojiStyle = 'font-size: 0.9em; display: block;';

      let phaseClass = null;
      if (dayEntries.some(e => (e.phase || '').toLowerCase() === 'day1-period')) phaseClass = 'deep-red';
      else if (dayEntries.some(e => (e.phase || '').toLowerCase() === 'period')) phaseClass = 'red';
      else if (dayEntries.some(e => (e.phase || '').toLowerCase() === 'ovulation' || (e.opk || '').toLowerCase() === 'solid face')) phaseClass = 'bold-blue';
      else if (dayEntries.some(e => (e.opk || '').toLowerCase() === 'flashing face')) phaseClass = 'blue';
      else if (dayEntries.some(e => (e.phase || '').toLowerCase() === 'post-ovulation')) phaseClass = 'green';

      if (phaseClass) box.classList.add(phaseClass);

      const iconFlags = {
        sex: false,
        breastChanges: false,
        digestive: false,
        bbt: false,
        cramps: false,
        spotting: false,
        mood: false
      };

      dayEntries.forEach(e => {
        if ((e.sex || '').toLowerCase() === 'yes') iconFlags.sex = true;
        if (e.breastChanges && e.breastChanges.toLowerCase() !== 'none') iconFlags.breastChanges = true;
        if (e.digestive && e.digestive.toLowerCase() !== 'none') iconFlags.digestive = true;
        if (e.bbt && !isNaN(parseFloat(e.bbt))) iconFlags.bbt = true;
        if (e.cramps && e.cramps.toLowerCase() !== 'none') iconFlags.cramps = true;
        if (e.spotting && e.spotting.toLowerCase() !== 'none') iconFlags.spotting = true;
        if (e.mood) iconFlags.mood = true;
      });

      if (iconFlags.sex) box.appendChild(Object.assign(document.createElement('span'), { textContent: 'üíñ', style: emojiStyle }));
      if (iconFlags.cramps) box.appendChild(Object.assign(document.createElement('span'), { textContent: 'üòñ', style: emojiStyle }));
      if (iconFlags.spotting) box.appendChild(Object.assign(document.createElement('span'), { textContent: 'üîª', style: emojiStyle }));
      if (iconFlags.mood) box.appendChild(Object.assign(document.createElement('span'), { textContent: 'üß†', style: emojiStyle }));
      if (iconFlags.breastChanges) box.appendChild(Object.assign(document.createElement('span'), { textContent: 'ü´∂', style: emojiStyle }));
      if (iconFlags.digestive) box.appendChild(Object.assign(document.createElement('span'), { textContent: 'ü´É', style: emojiStyle }));
      if (iconFlags.bbt) box.appendChild(Object.assign(document.createElement('span'), { textContent: 'üå°Ô∏è', style: emojiStyle }));

      box.title = dayEntries.map(e => {
        let parts = [];
        if (e.mood) parts.push(`Mood: ${e.mood}`);
        if (e.cramps && e.cramps.toLowerCase() !== 'none') parts.push(`Cramps: ${e.cramps}`);
        if (e.spotting && e.spotting.toLowerCase() !== 'none') parts.push(`Spotting: ${e.spotting}`);
        if (e.sex && e.sex.toLowerCase() === 'yes') parts.push(`Sex: Yes`);
        if (e.bbt) parts.push(`BBT: ${e.bbt}`);
        if (e.breastChanges && e.breastChanges.toLowerCase() !== 'none') parts.push(`Breast Changes`);
        if (e.digestive && e.digestive.toLowerCase() !== 'none') parts.push(`Digestive Symptoms`);
        return parts.join('\n');
      }).join('\n\n');

    } else if (predictionDays[key]) {
      box.appendChild(Object.assign(document.createElement('span'), {
        textContent: predictionDays[key],
        style: 'font-size: 0.9em; display: block; opacity: 0.6;'
      }));
    }

    container.appendChild(box);
  }

  viewMonth = month;
  viewYear = year;

  document.getElementById("monthLabel").textContent = new Date(year, month).toLocaleString('default', { month: 'long', year: 'numeric' });
}

function changeMonth(offset) {
  const newDate = new Date(viewYear, viewMonth + offset);
  viewMonth = newDate.getMonth();
  viewYear = newDate.getFullYear();

  renderCalendar(viewMonth, viewYear);
  renderCharts(cycles); // full cycles
}

// render BBT by cycle with period day 1 and ovulation vertical lines
function renderBBTChart(cycle) {
  if (bbtChartInstance) {
    bbtChartInstance.destroy();
    bbtChartInstance = null;
  }

  if (!cycle || cycle.length === 0) {
    document.getElementById('bbtChart').getContext('2d').clearRect(0, 0, 900, 400);
    return;
  }

  // Extract unique days sorted for X axis and map entry by date
  const uniqueDates = [...new Set(cycle.map(e => new Date(e.entryDate).toISOString().slice(0,10)))].sort();

  // For each date, get BBT value (take first entry per day with valid bbt)
  const bbtValues = uniqueDates.map(date => {
    const entry = cycle.find(e => new Date(e.entryDate).toISOString().slice(0,10) === date && e.bbt && !isNaN(parseFloat(e.bbt)));
    return entry ? parseFloat(entry.bbt) : null;
  });

  // X axis labels in day number format: Day 1, Day 2, ...
  const labels = uniqueDates.map((d,i) => `Day ${i+1}`);

  // Find Period Day 1 index (first day with phase day1-period)
  const periodDayIndex = uniqueDates.findIndex(date => cycle.some(e => {
    return (e.phase || '').toLowerCase() === 'day1-period' && new Date(e.entryDate).toISOString().slice(0,10) === date;
  }));

  // Find Ovulation Day index (day with opk 'solid face')
  const ovulationDayIndex = uniqueDates.findIndex(date => cycle.some(e => {
    return (e.opk || '').toLowerCase() === 'solid face' && new Date(e.entryDate).toISOString().slice(0,10) === date;
  }));

  // Prepare vertical lines plugin for period and ovulation markers
  const verticalLinesPlugin = {
    id: 'verticalLines',
    afterDatasetsDraw(chart, args, options) {
      const ctx = chart.ctx;
      const xAxis = chart.scales['x'];
      const yAxis = chart.scales['y'];

      ctx.save();
      ctx.lineWidth = 2;

      if (periodDayIndex !== -1) {
        const x = xAxis.getPixelForValue(periodDayIndex);
        ctx.strokeStyle = '#F44336'; // Red for period
        ctx.beginPath();
        ctx.moveTo(x, yAxis.top);
        ctx.lineTo(x, yAxis.bottom);
        ctx.stroke();
      }

      if (ovulationDayIndex !== -1) {
        const x = xAxis.getPixelForValue(ovulationDayIndex);
        ctx.strokeStyle = '#FFC107'; // Yellow for ovulation
        ctx.beginPath();
        ctx.moveTo(x, yAxis.top);
        ctx.lineTo(x, yAxis.bottom);
        ctx.stroke();
      }

      ctx.restore();
    }
  };

  bbtChartInstance = new Chart(document.getElementById('bbtChart').getContext('2d'), {
    type: 'line',
    data: {
      labels: labels,
      datasets: [{
        label: 'BBT',
        data: bbtValues,
        borderColor: 'purple',
        fill: false,
        tension: 0.1,
        spanGaps: true,
        pointRadius: 4,
        pointHoverRadius: 6,
      }]
    },
    options: {
      responsive: true,
      scales: {
        y: { 
          title: { display: true, text: 'Temperature (¬∞C)' },
          min: Math.min(...bbtValues.filter(v => v !== null)) - 0.3,
          max: Math.max(...bbtValues.filter(v => v !== null)) + 0.3,
        },
        x: {
          title: { display: true, text: 'Cycle Day' },
          ticks: { maxRotation: 0, autoSkip: false }
        }
      },
      plugins: {
        legend: { display: true },
        tooltip: { mode: 'index', intersect: false }
      }
    },
    plugins: [verticalLinesPlugin]
  });
}

// Other charts rendering left unchanged ‚Äî copy your existing code here or keep same

function renderCharts(cyclesLocal) {
  // We'll render only non-BBT charts here for brevity
  // Copy your existing rendering code here or keep your prior functions for CM, symptoms, mood, etc.
}

function run() {
  return db.collection("entries").orderBy("entryDate").get()
    .then(snapshot => {
      allEntries = snapshot.docs.map(doc => doc.data());

      cycles = groupCycles(allEntries);
      calculateAverages(cycles);

      // Start with most recent cycle (last in array)
      currentCycleIndex = cycles.length - 1;

      renderCalendar(viewMonth, viewYear);
      renderBBTChart(cycles[currentCycleIndex]);
      renderCharts(cycles);
      updateButtons();
    });
}

function updateButtons() {
  document.getElementById('prevCycleBtn').disabled = currentCycleIndex <= 0;
  document.getElementById('nextCycleBtn').disabled = currentCycleIndex >= cycles.length -1;
}

document.getElementById('prevCycleBtn').addEventListener('click', () => {
  if (currentCycleIndex > 0) {
    currentCycleIndex--;
    renderBBTChart(cycles[currentCycleIndex]);
    updateButtons();
  }
});
document.getElementById('nextCycleBtn').addEventListener('click', () => {
  if (currentCycleIndex < cycles.length -1) {
    currentCycleIndex++;
    renderBBTChart(cycles[currentCycleIndex]);
    updateButtons();
  }
});

</script>
</body>
</html>
