<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cycle History</title>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: 'Segoe UI', sans-serif; background: #fffafc; padding: 1em; }
    h1, h2, h3 { text-align: center; }
    .nav-button {
      display: block; margin: 1em auto; background: #c4d7b2;
      color: white; padding: 0.6em 1.2em; border-radius: 20px;
      text-align: center; text-decoration: none; max-width: 250px;
    }
    .legend {
      display: flex; flex-wrap: wrap; gap: 0.5em;
      justify-content: center; margin-bottom: 1em;
    }
    .legend span {
      display: inline-block; padding: 0.4em 0.8em;
      border-radius: 5px; font-size: 0.75em;
    }
    .calendar-nav {
      display: flex; justify-content: center; gap: 1em; margin: 0.5em 0;
    }
    .calendar-grid {
      display: grid; grid-template-columns: repeat(7, 1fr);
      gap: 5px; margin-bottom: 1.5em;
    }
    .weekday { font-weight: bold; text-align: center; }
    .day-box {
      padding: 0.6em 0;
      border-radius: 6px;
      background: #f0f0f0;
      text-align: center;
      font-size: 0.85em;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      min-height: 3.5em;
      position: relative;
    }
    .deep-red { background: #e76f8a !important; color: white !important; }
    .red { background: #f6b1b7 !important; }
    .blue { background: #b7d7f6 !important; }
    .bold-blue { background: #5f9ed1 !important; color: white !important; }
    .green { background: #c8e6c9 !important; }
    .chart-container {
      margin: 2em auto; max-width: 900px;
    }
    table {
      width: 100%; border-collapse: collapse; margin: 1em 0; font-size: 0.95em;
    }
    th, td {
      padding: 0.5em; border: 1px solid #ccc; text-align: center;
    }
    th {
      background: #eeb7c2; color: white;
    }
    .day-box span {
      font-size: 1.1em;
      display: block;
      opacity: 0.8;
      line-height: 1;
    }
  </style>
</head>
<body>
  <h1>Cycle History</h1>
  <a class="nav-button" href="index.html">‚Üê Back to Home</a>

  <h2>Cycle Averages</h2>
  <table>
    <thead>
      <tr>
        <th>Avg. Cycle Length</th>
        <th>Avg. Luteal Phase</th>
        <th>Avg. Fertile Window Start</th>
        <th>Avg. Ovulation Day</th>
        <th>Avg. Period Length</th>
        <th>Avg. Sex Entries / Cycle</th>
      </tr>
    </thead>
    <tbody>
      <tr id="averagesRow">
        <td>‚Äì</td>
        <td>‚Äì</td>
        <td>‚Äì</td>
        <td>‚Äì</td>
        <td>‚Äì</td>
        <td>‚Äì</td>
      </tr>
    </tbody>
  </table>

  <div class="legend">
    <span style="background:#e76f8a; color:white;">Day 1 Period</span>
    <span style="background:#f6b1b7;">Period</span>
    <span style="background:#b7d7f6;">Fertile (Flashing)</span>
    <span style="background:#5f9ed1; color:white;">Ovulation (Solid)</span>
    <span style="background:#c8e6c9;">Post Ovulation</span>
    <span style="background:#fff0f5;">üíñ Sex</span>
    <span style="background:#fff0f5;">üòñ Cramps</span>
    <span style="background:#fff0f5;">üîª Spotting</span>
    <span style="background:#fff0f5;">üß† Mood</span>
    <span style="background:#fff0f5;">üå°Ô∏è BBT</span>
    <span style="background:#fff0f5;">ü´∂ Breast Changes</span>
    <span style="background:#fff0f5;">ü´É Digestive</span>
  </div>

  <div id="predictionBanner" style="text-align:center; margin-bottom: 1em; font-weight: bold;"></div>

  <div class="calendar-nav">
    <button onclick="changeMonth(-1)">‚óÄ</button>
    <span id="monthLabel"></span>
    <button onclick="changeMonth(1)">‚ñ∂</button>
  </div>

  <div style="text-align:center; margin-bottom:1em; font-weight:bold;">
    <span>Predictions: </span>
    <span style="color:#F44336;">üî¥ Period Days</span>
    <span style="color:#4CAF50;">üü¢ Fertile Window</span> | 
    <span style="color:#FFC107;">üü° Ovulation Day</span>
  </div>

  <div class="calendar-grid" id="calendarWeekdays"></div>
  <div class="calendar-grid" id="calendarGrid"></div>

  <div class="chart-container">
    <h2>BBT Chart</h2>
    <canvas id="bbtChart"></canvas>
  </div>
  <div class="chart-container">
    <h2>CM Pattern</h2>
    <canvas id="cmChart"></canvas>
  </div>
  <div class="chart-container">
    <h2>Average Symptoms</h2>
    <canvas id="symptomsChart"></canvas>
  </div>
  <div class="chart-container">
    <h2>Mood Timeline</h2>
    <canvas id="moodChart"></canvas>
  </div>

  <script>
    // Firebase config and initialization
    const firebaseConfig = {
      apiKey: "AIzaSyByvnVx2aZEldUfqS2c6VNC6UJRIOPvGws",
      authDomain: "fertility-tracker-c35ff.firebaseapp.com",
      projectId: "fertility-tracker-c35ff"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    let allEntries = [];
    let viewMonth = new Date().getMonth();
    let viewYear = new Date().getFullYear();

    // Averages
    let avgCycleLength = null;
    let avgLutealLength = null;
    let avgFertileWindowStart = null;
    let avgOvulationDay = null;
    let avgPeriodLength = null;
    let avgSexEntries = null;

    auth.onAuthStateChanged(async (user) => {
      if (!user) {
        window.location.href = "index.html";
        return;
      }
      await run();
    });

    async function loadEntries() {
      const legacySnapshot = await db.collection("entries")
        .where("uid", "==", auth.currentUser.uid)
        .orderBy("entryDate")
        .get();

      const userScopedSnapshot = await db.collection("users")
        .doc(auth.currentUser.uid)
        .collection("entries")
        .orderBy("entryDate")
        .get();

      const legacyEntries = legacySnapshot.docs.map(doc => doc.data());
      const scopedEntries = userScopedSnapshot.docs.map(doc => doc.data());

      const mergedEntries = [...legacyEntries, ...scopedEntries];
      mergedEntries.sort((a, b) => new Date(a.entryDate) - new Date(b.entryDate));
      return mergedEntries;
    }

    function groupCycles(entries) {
      const cycles = [];
      let currentCycle = [];

      for (const e of entries) {
        if ((e.phase || '').toLowerCase() === 'day1-period') {
          if (currentCycle.length) cycles.push([...currentCycle]);
          currentCycle = [];
        }
        currentCycle.push(e);
      }
      if (currentCycle.length) cycles.push(currentCycle);
      return cycles;
    }

    function calculateAverages(cycles) {
      if (!cycles.length) {
        avgCycleLength = null;
        avgLutealLength = null;
        avgFertileWindowStart = null;
        avgOvulationDay = null;
        avgPeriodLength = null;
        avgSexEntries = null;
        return;
      }

      const cycleLengths = [];
      const lutealPhases = [];
      const periodLengths = [];
      const ovulationDays = [];
      const sexFreqPerCycle = [];

      cycles.forEach(cycle => {
        const start = new Date(cycle[0].entryDate);
        const end = new Date(cycle[cycle.length - 1].entryDate);
        const cycleLength = (end - start) / 86400000 + 1;
        if (cycleLength < 10) return; // Skip very short cycles

        const ovIndex = cycle.findIndex(e => (e.opk || '').toLowerCase() === 'solid face');
        if (ovIndex === -1) return; // Skip cycles without ovulation detected

        cycleLengths.push(cycleLength);
        lutealPhases.push(cycle.length - ovIndex - 1);
        periodLengths.push(cycle.filter(e => ['day1-period', 'period'].includes((e.phase || '').toLowerCase())).length);
        ovulationDays.push(ovIndex + 1);
        sexFreqPerCycle.push(cycle.filter(e => (e.sex || '').toLowerCase() === 'yes').length);
      });

      const avg = arr => arr.length ? Math.round(arr.reduce((a,b) => a + b, 0) / arr.length) : null;

      avgCycleLength = avg(cycleLengths);
      avgLutealLength = avg(lutealPhases);
      avgOvulationDay = avg(ovulationDays);
      avgFertileWindowStart = avgOvulationDay !== null ? avgOvulationDay - 5 : null;
      avgPeriodLength = avg(periodLengths);
      avgSexEntries = avg(sexFreqPerCycle);

      // Update averages table
      document.getElementById("averagesRow").innerHTML = `
        <td>${avgCycleLength ?? '‚Äì'}</td>
        <td>${avgLutealLength ?? '‚Äì'}</td>
        <td>${avgFertileWindowStart ?? '‚Äì'}</td>
        <td>${avgOvulationDay ?? '‚Äì'}</td>
        <td>${avgPeriodLength ?? '‚Äì'}</td>
        <td>${avgSexEntries ?? '‚Äì'}</td>
      `;
    }

    function generatePredictionDays() {
      let predictionDays = {};
      if (!allEntries.length || avgCycleLength === null || avgLutealLength === null || avgPeriodLength === null) return predictionDays;

      const lastDay1 = [...allEntries].reverse().find(e => (e.phase || '').toLowerCase() === 'day1-period');
      if (!lastDay1) return predictionDays;

      const cycleStart = new Date(lastDay1.entryDate);

      for (let cycleNum = 1; cycleNum <= 3; cycleNum++) {
        // Calculate predicted period start
        const predictedPeriodDate = new Date(cycleStart);
        predictedPeriodDate.setDate(predictedPeriodDate.getDate() + avgCycleLength * cycleNum);

        // Calculate predicted ovulation day
        const ovDate = new Date(predictedPeriodDate);
        ovDate.setDate(ovDate.getDate() - avgLutealLength);

        // Calculate fertile window start based on average ovulation day minus 5 days
        const fertileStart = new Date(ovDate);
        fertileStart.setDate(fertileStart.getDate() - 5);

        // Mark fertile window days
        for (let i = 0; i <= 4; i++) {
          const d = new Date(fertileStart);
          d.setDate(d.getDate() + i);
          predictionDays[d.toLocaleDateString('en-CA')] = 'üü¢';
        }

        // Mark ovulation day
        predictionDays[ovDate.toLocaleDateString('en-CA')] = 'üü°';

        // Mark period days
        for (let i = 0; i < avgPeriodLength; i++) {
          const d = new Date(predictedPeriodDate);
          d.setDate(d.getDate() + i);
          predictionDays[d.toLocaleDateString('en-CA')] = 'üî¥';
        }
      }

      return predictionDays;
    }

    function groupEntriesByDate(entries) {
      return entries.reduce((acc, e) => {
        const dateKey = new Date(e.entryDate).toLocaleDateString('en-CA');
        if (!acc[dateKey]) acc[dateKey] = [];
        acc[dateKey].push(e);
        return acc;
      }, {});
    }

    function renderCalendar(month, year) {
      const container = document.getElementById("calendarGrid");
      container.innerHTML = "";

      document.getElementById("calendarWeekdays").innerHTML = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun']
        .map(d => `<div class="weekday">${d}</div>`).join('');

      const map = groupEntriesByDate(allEntries);
      const predictionDays = generatePredictionDays();

      const start = new Date(year, month, 1);
      const end = new Date(year, month + 1, 0);
      const offset = (start.getDay() + 6) % 7;

      for(let i=0; i < offset; i++) {
        container.appendChild(document.createElement("div"));
      }

      for(let d=1; d <= end.getDate(); d++) {
        const date = new Date(year, month, d);
        const key = date.toLocaleDateString('en-CA');
        const dayEntries = map[key] || [];

        const box = document.createElement("div");
        box.className = "day-box";
        box.textContent = d;

        if(dayEntries.length) {
          const emojiStyle = 'font-size: 0.9em; display: block;';

          let phaseClass = null;
          if (dayEntries.some(e => (e.phase || '').toLowerCase() === 'day1-period')) phaseClass = 'deep-red';
          else if (dayEntries.some(e => (e.phase || '').toLowerCase() === 'period')) phaseClass = 'red';
          else if (dayEntries.some(e => (e.phase || '').toLowerCase() === 'ovulation' || (e.opk || '').toLowerCase() === 'solid face')) phaseClass = 'bold-blue';
          else if (dayEntries.some(e => (e.opk || '').toLowerCase() === 'flashing face')) phaseClass = 'blue';
          else if (dayEntries.some(e => (e.phase || '').toLowerCase() === 'post-ovulation')) phaseClass = 'green';

          if (phaseClass) box.classList.add(phaseClass);

          // Add icons
          const icons = {
            sex: false,
            breastChanges: false,
            digestive: false,
            bbt: false,
            cramps: false,
            spotting: false,
            mood: false
          };

          dayEntries.forEach(e => {
            if ((e.sex || '').toLowerCase() === 'yes') icons.sex = true;
            if (e.breastChanges && e.breastChanges.toLowerCase() !== 'none') icons.breastChanges = true;
            if (e.digestive && e.digestive.toLowerCase() !== 'none') icons.digestive = true;
            if (e.bbt && !isNaN(parseFloat(e.bbt))) icons.bbt = true;
            if (e.cramps && e.cramps.toLowerCase() !== 'none') icons.cramps = true;
            if (e.spotting && e.spotting.toLowerCase() !== 'none') icons.spotting = true;
            if (e.mood) icons.mood = true;
          });

          if (icons.sex) box.appendChild(Object.assign(document.createElement('span'), { textContent: 'üíñ', style: emojiStyle }));
          if (icons.cramps) box.appendChild(Object.assign(document.createElement('span'), { textContent: 'üòñ', style: emojiStyle }));
          if (icons.spotting) box.appendChild(Object.assign(document.createElement('span'), { textContent: 'üîª', style: emojiStyle }));
          if (icons.mood) box.appendChild(Object.assign(document.createElement('span'), { textContent: 'üß†', style: emojiStyle }));
          if (icons.breastChanges) box.appendChild(Object.assign(document.createElement('span'), { textContent: 'ü´∂', style: emojiStyle }));
          if (icons.digestive) box.appendChild(Object.assign(document.createElement('span'), { textContent: 'ü´É', style: emojiStyle }));
          if (icons.bbt) box.appendChild(Object.assign(document.createElement('span'), { textContent: 'üå°Ô∏è', style: emojiStyle }));

          // Tooltip with entry details
          box.title = dayEntries.map(e => {
            let parts = [];
            if (e.mood) parts.push(`Mood: ${e.mood}`);
            if (e.cramps && e.cramps.toLowerCase() !== 'none') parts.push(`Cramps: ${e.cramps}`);
            if (e.spotting && e.spotting.toLowerCase() !== 'none') parts.push(`Spotting: ${e.spotting}`);
            if (e.sex && e.sex.toLowerCase() === 'yes') parts.push(`Sex: Yes`);
            if (e.bbt) parts.push(`BBT: ${e.bbt}`);
            if (e.breastChanges && e.breastChanges.toLowerCase() !== 'none') parts.push(`Breast Changes`);
            if (e.digestive && e.digestive.toLowerCase() !== 'none') parts.push(`Digestive Symptoms`);
            return parts.join('\n');
          }).join('\n\n');

        } else if (predictionDays[key]) {
          box.appendChild(Object.assign(document.createElement('span'), {
            textContent: predictionDays[key],
            style: 'font-size: 0.9em; display: block; opacity: 0.6;'
          }));
        }

        container.appendChild(box);
      }

      document.getElementById("monthLabel").textContent = new Date(year, month).toLocaleString('default', { month: 'long', year: 'numeric' });
      viewMonth = month;
      viewYear = year;
    }

    function renderCharts(cycles) {
      if (!cycles.length) {
        // Clear charts or show no data
        clearAllCharts();
        return;
      }

      // Prepare BBT data (for selected month and year)
      const bbtEntries = allEntries.filter(e => {
        const d = new Date(e.entryDate);
        return d.getMonth() === viewMonth && d.getFullYear() === viewYear && !isNaN(parseFloat(e.bbt));
      }).sort((a,b) => new Date(a.entryDate) - new Date(b.entryDate));

      const bbtLabels = bbtEntries.map(e => {
        const d = new Date(e.entryDate);
        return d.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });
      });
      const bbtData = bbtEntries.map(e => parseFloat(e.bbt));

      // Chart: BBT
      if(window.bbtChartInstance) window.bbtChartInstance.destroy();
      window.bbtChartInstance = new Chart(document.getElementById("bbtChart"), {
        type: 'line',
        data: {
          labels: bbtLabels.length ? bbtLabels : ['No Data'],
          datasets: [{
            label: "BBT",
            data: bbtData.length ? bbtData : [null],
            borderColor: 'purple',
            fill: false,
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          scales: {
            y: { title: { display: true, text: 'Temperature (¬∞C)' } },
            x: { title: { display: true, text: 'Date' } }
          }
        }
      });

      // Chart: CM Pattern averages per cycle
      const cmTypes = ['dry', 'sticky', 'creamy', 'watery', 'egg white'];
      const cmTypeCounts = { dry: 0, sticky: 0, creamy: 0, watery: 0, 'egg white': 0 };
      let totalCycles = cycles.length || 1;

      cycles.forEach(cycle => {
        const typesSeen = new Set();
        cycle.forEach(e => {
          const cm = (e.cm || '').toLowerCase();
          if (cmTypes.includes(cm)) typesSeen.add(cm);
        });
        typesSeen.forEach(cm => cmTypeCounts[cm]++);
      });

      const cmChartLabels = ['Dry', 'Sticky', 'Creamy', 'Watery', 'Egg White'];
      const cmChartData = cmChartLabels.map(label => {
        const key = label.toLowerCase();
        return totalCycles ? (cmTypeCounts[key] / totalCycles).toFixed(2) : 0;
      });

      if(window.cmChartInstance) window.cmChartInstance.destroy();
      window.cmChartInstance = new Chart(document.getElementById("cmChart"), {
        type: 'bar',
        data: {
          labels: cmChartLabels,
          datasets: [{
            label: 'Avg. CM Occurrence per Cycle',
            data: cmChartData,
            backgroundColor: ['#fde2e4', '#fad2e1', '#dfe7fd', '#cdeac0', '#b5ead7']
          }]
        },
        options: {
          responsive: true,
          scales: { y: { beginAtZero: true, title: { display: true, text: 'Average Occurrence' } } }
        }
      });

      // Chart: Average Symptoms per cycle
      const symptomsAvg = { cramps: 0, spotting: 0, breastChanges: 0, digestive: 0 };

      cycles.forEach(cycle => {
        symptomsAvg.cramps += cycle.filter(e => (e.cramps || '').toLowerCase() !== 'none').length / cycle.length;
        symptomsAvg.spotting += cycle.filter(e => (e.spotting || '').toLowerCase() !== 'none').length / cycle.length;
        symptomsAvg.breastChanges += cycle.filter(e => (e.breastChanges || '').toLowerCase() !== 'none').length / cycle.length;
        symptomsAvg.digestive += cycle.filter(e => (e.digestive || '').toLowerCase() !== 'none').length / cycle.length;
      });

      Object.keys(symptomsAvg).forEach(key => symptomsAvg[key] /= totalCycles);

      if(window.symptomsChartInstance) window.symptomsChartInstance.destroy();
      window.symptomsChartInstance = new Chart(document.getElementById("symptomsChart"), {
        type: 'bar',
        data: {
          labels: ['Cramps', 'Spotting', 'Breast Changes', 'Digestive'],
          datasets: [{
            label: 'Avg. Symptom Occurrence per Cycle',
            data: [
              symptomsAvg.cramps || 0,
              symptomsAvg.spotting || 0,
              symptomsAvg.breastChanges || 0,
              symptomsAvg.digestive || 0
            ],
            backgroundColor: ['#f28e8e', '#f2c28e', '#a8d0e6', '#c3aed6']
          }]
        },
        options: { responsive: true }
      });

      // Chart: Mood Timeline (frequency of mood entries)
      const knownMoods = ['Calm', 'Happy', 'Irritable', 'Low'];
      const moodColors = { Calm: '#87cefa', Happy: '#ffd700', Irritable: '#ffa07a', Low: '#ff6b6b' };
      const moodFreq = {};
      knownMoods.forEach(m => moodFreq[m] = 0);

      allEntries.forEach(e => {
        const mood = (e.mood || '').trim();
        if (knownMoods.includes(mood)) moodFreq[mood]++;
      });

      if(window.moodChartInstance) window.moodChartInstance.destroy();
      window.moodChartInstance = new Chart(document.getElementById("moodChart"), {
        type: 'bar',
        data: {
          labels: knownMoods,
          datasets: [{
            label: 'Mood Frequency (All Time)',
            data: knownMoods.map(m => moodFreq[m]),
            backgroundColor: knownMoods.map(m => moodColors[m])
          }]
        },
        options: {
          responsive: true,
          scales: {
            y: { beginAtZero: true, title: { display: true, text: 'Number of Entries' } },
            x: { title: { display: true, text: 'Mood Type' } }
          }
        }
      });
    }

    function clearAllCharts() {
      ['bbtChartInstance','cmChartInstance','symptomsChartInstance','moodChartInstance'].forEach(chartVar => {
        if(window[chartVar]) {
          window[chartVar].destroy();
          window[chartVar] = null;
        }
      });
    }

    function changeMonth(offset) {
      const newDate = new Date(viewYear, viewMonth + offset);
      viewMonth = newDate.getMonth();
      viewYear = newDate.getFullYear();
      renderCalendar(viewMonth, viewYear);
      const cycles = groupCycles(allEntries);
      renderCharts(cycles);
    }

    async function run() {
      allEntries = await loadEntries();
      const cycles = groupCycles(allEntries);
      calculateAverages(cycles);
      renderCalendar(viewMonth, viewYear);
      renderCharts(cycles);
    }
  </script>
</body>
</html>
