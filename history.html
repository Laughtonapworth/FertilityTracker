<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cycle History</title>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body { font-family: 'Segoe UI', sans-serif; background: #fffafc; padding: 1em; }
  h1, h2, h3 { text-align: center; }
  .nav-button {
    display: block; margin: 1em auto; background: #c4d7b2;
    color: white; padding: 0.6em 1.2em; border-radius: 20px;
    text-align: center; text-decoration: none; max-width: 250px;
  }
  .legend {
    display: flex; flex-wrap: wrap; gap: 0.5em;
    justify-content: center; margin-bottom: 1em;
  }
  .legend span {
    display: inline-block; padding: 0.4em 0.8em;
    border-radius: 5px; font-size: 0.75em;
  }
  .calendar-nav {
    display: flex; justify-content: center; gap: 1em; margin: 0.5em 0;
  }
  .calendar-grid {
    display: grid; grid-template-columns: repeat(7, 1fr);
    gap: 5px; margin-bottom: 1.5em;
  }
  .weekday { font-weight: bold; text-align: center; }
  .day-box {
    padding: 0.6em 0;
    border-radius: 6px;
    background: #f0f0f0;
    text-align: center;
    font-size: 0.85em;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    min-height: 3.5em;
    position: relative;
  }
  .deep-red { background: #e76f8a !important; color: white !important; }
  .red { background: #f6b1b7 !important; }
  .blue { background: #b7d7f6 !important; }
  .bold-blue { background: #5f9ed1 !important; color: white !important; }
  .green { background: #c8e6c9 !important; }
  .chart-container {
    margin: 2em auto; max-width: 900px;
  }
  table {
    width: 100%; border-collapse: collapse; margin: 1em 0; font-size: 0.95em;
  }
  th, td {
    padding: 0.5em; border: 1px solid #ccc; text-align: center;
  }
  th {
    background: #eeb7c2; color: white;
  }
  .day-box span {
    font-size: 1.1em;
    display: block;
    opacity: 0.8;
    line-height: 1;
  }
</style>
</head>
<body>

<h1>Cycle History</h1>
<a class="nav-button" href="index.html">‚Üê Back to Home</a>

<h2>Cycle Averages</h2>
<table>
  <thead>
    <tr>
      <th>Avg. Cycle Length</th>
      <th>Avg. Luteal Phase</th>
      <th>Avg. Period Length</th>
      <th>Avg. Ovulation Day</th>
      <th>Avg. Sex Entries / Cycle</th>
    </tr>
  </thead>
  <tbody><tr id="averagesRow"><td>‚Äì</td><td>‚Äì</td><td>‚Äì</td><td>‚Äì</td><td>‚Äì</td></tr></tbody>
</table>

<div class="legend">
  <span style="background:#e76f8a; color:white;">Day 1 Period</span>
  <span style="background:#f6b1b7;">Period</span>
  <span style="background:#b7d7f6;">Fertile (Flashing)</span>
  <span style="background:#5f9ed1; color:white;">Ovulation (Solid)</span>
  <span style="background:#c8e6c9;">Post Ovulation</span>
  <span style="background:#fff0f5;">üíñ Sex</span>
  <span style="background:#fff0f5;">üòñ Cramps</span>
  <span style="background:#fff0f5;">üîª Spotting</span>
  <span style="background:#fff0f5;">üß† Mood</span>
  <span style="background:#fff0f5;">üå°Ô∏è BBT</span>
  <span style="background:#fff0f5;">ü´∂ Breast Changes</span>
  <span style="background:#fff0f5;">ü´É Digestive</span>
</div>

<div id="predictionBanner" style="text-align:center; margin-bottom: 1em; font-weight: bold;"></div>

<div class="calendar-nav">
  <button onclick="changeMonth(-1)">‚óÄ</button>
  <span id="monthLabel"></span>
  <button onclick="changeMonth(1)">‚ñ∂</button>
</div>

<div style="text-align:center; margin-bottom:1em; font-weight:bold;">
  <span>Predictions: </span>
  <span style="color:#F44336;">üî¥ Period Days</span>
  <span style="color:#4CAF50;">üü¢ Fertile Window</span> | 
  <span style="color:#FFC107;">üü° Ovulation Day</span> | 
</div>

<div class="calendar-grid" id="calendarWeekdays"></div>
<div class="calendar-grid" id="calendarGrid"></div>

<div class="chart-container">
  <h2>BBT Chart</h2>
  <canvas id="bbtChart"></canvas>
</div>

<div class="chart-container">
  <h2>CM Pattern</h2>
  <canvas id="cmChart"></canvas>
</div>

<div class="chart-container">
  <h2>Average Symptoms</h2>
  <canvas id="symptomsChart"></canvas>
</div>

<div class="chart-container">
  <h2>Mood Timeline</h2>
  <canvas id="moodChart"></canvas>
</div>

<script>
  const firebaseConfig = {
    apiKey: "AIzaSyByvnVx2aZEldUfqS2c6VNC6UJRIOPvGws",
    authDomain: "fertility-tracker-c35ff.firebaseapp.com",
    projectId: "fertility-tracker-c35ff",
  };

  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();

  let allEntries = [];
  let viewMonth = new Date().getMonth();
  let viewYear = new Date().getFullYear();

  let avgCycleLength = null;
  let avgLutealLength = null;
  let avgPeriodLength = null;
  let avgOvulationDay = null;

  function uniquePerDay(entries) {
    const seen = new Set();
    const result = [];
    entries.forEach(e => {
      const key = new Date(e.entryDate).toISOString().slice(0,10);
      if (!seen.has(key)) {
        seen.add(key);
        result.push(e);
      }
    });
    return result;
  }

  auth.onAuthStateChanged(async user => {
    if (!user) {
      window.location.href = "index.html";
      return;
    }
    try {
      // Legacy entries
      const legacySnapshot = await db.collection("entries")
        .where("uid", "==", user.uid)
        .orderBy("entryDate")
        .get();
      const legacyEntries = legacySnapshot.docs.map(doc => doc.data());

      // User-scoped entries
      const userSnapshot = await db.collection("users")
        .doc(user.uid)
        .collection("entries")
        .orderBy("entryDate")
        .get();
      const userEntries = userSnapshot.docs.map(doc => doc.data());

      allEntries = [...legacyEntries, ...userEntries];
      allEntries.sort((a,b) => new Date(a.entryDate) - new Date(b.entryDate));

      runLogic();
    } catch(e) {
      console.error("Error loading entries", e);
    }
  });

  function runLogic() {
    const cycles = groupCycles(allEntries);
    calculateAverages(cycles);
    renderCalendar(viewMonth, viewYear);
    renderCharts(cycles);
    renderPredictionBanner();
  }

  function groupCycles(entries) {
    const cycles = [];
    let currentCycle = [];

    for (const e of entries) {
      if ((e.phase || '').toLowerCase() === 'day1-period') {
        if (currentCycle.length) cycles.push(currentCycle);
        currentCycle = [];
      }
      currentCycle.push(e);
    }
    if (currentCycle.length) cycles.push(currentCycle);
    return cycles;
  }

  function calculateAverages(cycles) {
    const cycleLengths = [];
    const lutealPhases = [];
    const periodLengths = [];
    const ovulationDays = [];
    const sexFreqPerCycle = [];
    const now = new Date();

    cycles.forEach(cycle => {
      const uniqueEntries = uniquePerDay(cycle);
      const hasSolidFace = uniqueEntries.some(e => (e.opk || '').toLowerCase() === 'solid face');
      const lastDate = new Date(uniqueEntries[uniqueEntries.length-1].entryDate);
      const daysSinceLast = (now - lastDate) / 86400000;

      if (!hasSolidFace || daysSinceLast <= 4) return;

      const start = new Date(uniqueEntries[0].entryDate);
      const end = new Date(uniqueEntries[uniqueEntries.length - 1].entryDate);
      const duration = Math.round((end - start) / 86400000) + 1;

      cycleLengths.push(duration);

      const ovIndex = uniqueEntries.findIndex(e => (e.opk || '').toLowerCase() === 'solid face');
      lutealPhases.push(uniqueEntries.length - ovIndex - 1);
      ovulationDays.push(ovIndex + 1);

      const periodCount = uniqueEntries.filter(e => ['day1-period', 'period'].includes((e.phase || '').toLowerCase())).length;
      periodLengths.push(periodCount);

      const sexCount = uniqueEntries.filter(e => (e.sex || '').trim().toLowerCase() === 'yes').length;
      sexFreqPerCycle.push(sexCount);
    });

    avgCycleLength = cycleLengths.length ? (cycleLengths.reduce((a,b) => a + b, 0) / cycleLengths.length) : null;
    avgLutealLength = lutealPhases.length ? (lutealPhases.reduce((a,b) => a + b, 0) / lutealPhases.length) : null;
    avgPeriodLength = periodLengths.length ? (periodLengths.reduce((a,b) => a + b, 0) / periodLengths.length) : null;
    avgOvulationDay = ovulationDays.length ? (ovulationDays.reduce((a,b) => a + b, 0) / ovulationDays.length) : null;
    const avgSexFreq = sexFreqPerCycle.length ? (sexFreqPerCycle.reduce((a,b) => a + b, 0) / sexFreqPerCycle.length) : null;

    document.getElementById("averagesRow").innerHTML = `
      <td>${avgCycleLength ? avgCycleLength.toFixed(1) : '‚Äì'}</td>
      <td>${avgLutealLength ? avgLutealLength.toFixed(1) : '‚Äì'}</td>
      <td>${avgPeriodLength ? avgPeriodLength.toFixed(1) : '‚Äì'}</td>
      <td>${avgOvulationDay ? avgOvulationDay.toFixed(1) : '‚Äì'}</td>
      <td>${avgSexFreq ? avgSexFreq.toFixed(1) : '‚Äì'}</td>
    `;
  }

  function groupEntriesByDate(entries) {
    return entries.reduce((acc, e) => {
      const dateKey = new Date(e.entryDate).toISOString().slice(0,10);
      if (!acc[dateKey]) acc[dateKey] = [];
      acc[dateKey].push(e);
      return acc;
    }, {});
  }

  function generatePredictionDays() {
    const predictionDays = {};
    const lastDay1 = [...allEntries].slice().reverse().find(e => (e.phase || '').toLowerCase() === 'day1-period');

    if (!lastDay1 || !avgCycleLength || !avgLutealLength) return predictionDays;

    const cycleStart = new Date(lastDay1.entryDate);

    for (let cycleNum = 1; cycleNum <= 3; cycleNum++) {
      const predictedPeriodDate = new Date(cycleStart);
      predictedPeriodDate.setDate(predictedPeriodDate.getDate() + Math.round(avgCycleLength) * cycleNum);

      const ovDate = new Date(predictedPeriodDate);
      ovDate.setDate(ovDate.getDate() - Math.round(avgLutealLength));

      const fertileStart = new Date(ovDate);
      fertileStart.setDate(fertileStart.getDate() - 5);

      for (let i = 0; i <= 4; i++) {
        const d = new Date(fertileStart);
        d.setDate(d.getDate() + i);
        predictionDays[d.toISOString().slice(0,10)] = 'üü¢';
      }

      predictionDays[ovDate.toISOString().slice(0,10)] = 'üü°';

      const periodLength = Math.round(avgPeriodLength) || 5;
      for (let i = 0; i < periodLength; i++) {
        const pd = new Date(predictedPeriodDate);
        pd.setDate(pd.getDate() + i);
        predictionDays[pd.toISOString().slice(0,10)] = 'üî¥';
      }
    }
    return predictionDays;
  }

  function renderCalendar(month, year) {
    const container = document.getElementById("calendarGrid");
    container.innerHTML = "";

    document.getElementById("calendarWeekdays").innerHTML = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun']
      .map(d => `<div class="weekday">${d}</div>`).join('');

    const entriesByDate = groupEntriesByDate(allEntries);
    const predictionDays = generatePredictionDays();

    const start = new Date(year, month, 1);
    const end = new Date(year, month + 1, 0);
    const offset = (start.getDay() + 6) % 7;

    for (let i = 0; i < offset; i++) {
      container.appendChild(document.createElement("div"));
    }

    for (let d = 1; d <= end.getDate(); d++) {
      const date = new Date(year, month, d);
      const dateKey = date.toISOString().slice(0,10);
      const dayEntries = entriesByDate[dateKey] || [];

      const box = document.createElement("div");
      box.className = "day-box";
      box.textContent = d;

      if (dayEntries.length) {
        let phaseClass = null;
        if (dayEntries.some(e => (e.phase || '').toLowerCase() === 'day1-period')) phaseClass = 'deep-red';
        else if (dayEntries.some(e => (e.phase || '').toLowerCase() === 'period')) phaseClass = 'red';
        else if (dayEntries.some(e => (e.phase || '').toLowerCase() === 'ovulation' || (e.opk || '').toLowerCase() === 'solid face')) phaseClass = 'bold-blue';
        else if (dayEntries.some(e => (e.opk || '').toLowerCase() === 'flashing face')) phaseClass = 'blue';
        else if (dayEntries.some(e => (e.phase || '').toLowerCase() === 'post-ovulation')) phaseClass = 'green';

        if (phaseClass) box.classList.add(phaseClass);

        const emojiStyle = 'font-size: 0.9em; display: block;';
        const icons = {
          sex: false, breastChanges: false, digestive: false,
          bbt: false, cramps: false, spotting: false, mood: false
        };

        dayEntries.forEach(e => {
          if ((e.sex || '').toLowerCase() === 'yes') icons.sex = true;
          if (e.breastChanges && e.breastChanges.toLowerCase() !== 'none') icons.breastChanges = true;
          if (e.digestive && e.digestive.toLowerCase() !== 'none') icons.digestive = true;
          if (e.bbt && !isNaN(parseFloat(e.bbt))) icons.bbt = true;
          if (e.cramps && e.cramps.toLowerCase() !== 'none') icons.cramps = true;
          if (e.spotting && e.spotting.toLowerCase() !== 'none') icons.spotting = true;
          if (e.mood) icons.mood = true;
        });

        if (icons.sex) box.appendChild(Object.assign(document.createElement('span'), {textContent:'üíñ', style: emojiStyle}));
        if (icons.cramps) box.appendChild(Object.assign(document.createElement('span'), {textContent:'üòñ', style: emojiStyle}));
        if (icons.spotting) box.appendChild(Object.assign(document.createElement('span'), {textContent:'üîª', style: emojiStyle}));
        if (icons.mood) box.appendChild(Object.assign(document.createElement('span'), {textContent:'üß†', style: emojiStyle}));
        if (icons.breastChanges) box.appendChild(Object.assign(document.createElement('span'), {textContent:'ü´∂', style: emojiStyle}));
        if (icons.digestive) box.appendChild(Object.assign(document.createElement('span'), {textContent:'ü´É', style: emojiStyle}));
        if (icons.bbt) box.appendChild(Object.assign(document.createElement('span'), {textContent:'üå°Ô∏è', style: emojiStyle}));
      } else if (predictionDays[dateKey]) {
        box.appendChild(Object.assign(document.createElement('span'), {
          textContent: predictionDays[dateKey],
          style: 'font-size: 0.9em; display: block; opacity: 0.6;'
        }));
      }

      container.appendChild(box);
    }

    viewMonth = month;
    viewYear = year;

    document.getElementById("monthLabel").textContent = new Date(year, month).toLocaleString('default', { month: 'long', year: 'numeric' });
  }

  function changeMonth(offset) {
    const newDate = new Date(viewYear, viewMonth + offset);
    viewMonth = newDate.getMonth();
    viewYear = newDate.getFullYear();
    renderCalendar(viewMonth, viewYear);
    renderCharts(groupCycles(allEntries));
  }

  function groupAllCycles(entries) {
    const cycles = [];
    let currentCycle = [];
    for (const e of entries) {
      if ((e.phase || '').toLowerCase() === 'day1-period') {
        if (currentCycle.length) cycles.push([...currentCycle]);
        currentCycle = [];
      }
      currentCycle.push(e);
    }
    if (currentCycle.length) cycles.push(currentCycle);
    return cycles;
  }

  function renderCharts(cycles) {
    if (!cycles || cycles.length === 0) {
      console.warn("No cycle data for charts.");
      return;
    }

    // BBT data for full current cycle + previous cycles shown
    const bbtEntries = [];
    const periodMarkers = [];
    const ovulationMarkers = [];

    cycles.forEach(cycle => {
      // unique entries per day
      const uniqueCycleEntries = uniquePerDay(cycle);
      uniqueCycleEntries.forEach((entry, idx) => {
        if (entry.bbt && !isNaN(parseFloat(entry.bbt))) {
          const date = new Date(entry.entryDate);
          bbtEntries.push({date, bbt: parseFloat(entry.bbt)});
        }
      });

      // Add period day1 marker (day1-period) - first day of cycle
      const day1Entry = uniqueCycleEntries.find(e => (e.phase || '').toLowerCase() === 'day1-period');
      if (day1Entry) {
        const d = new Date(day1Entry.entryDate);
        periodMarkers.push(d);
      }

      // Add ovulation marker (solid face)
      const ovEntry = uniqueCycleEntries.find(e => (e.opk || '').toLowerCase() === 'solid face');
      if (ovEntry) {
        ovulationMarkers.push(new Date(ovEntry.entryDate));
      }
    });

    // Sort BBT entries by date
    bbtEntries.sort((a,b) => a.date - b.date);

    const labels = bbtEntries.map(e => e.date.toLocaleDateString('en-GB', {day:'numeric', month:'short'}));
    const dataPoints = bbtEntries.map(e => e.bbt);

    // Destroy previous chart if exists
    if(window.bbtChartInstance) window.bbtChartInstance.destroy();

    // Plugin to draw vertical lines for period day 1 and ovulation
    const verticalLinePlugin = {
      id: 'verticalLinePlugin',
      afterDatasetsDraw(chart) {
        const ctx = chart.ctx;
        const xAxis = chart.scales['x'];
        const yAxis = chart.scales['y'];

        // Helper to draw vertical line
        function drawLine(date) {
          const index = labels.findIndex(label => {
            const dt = new Date(date);
            return dt.toLocaleDateString('en-GB', {day:'numeric', month:'short'}) === label;
          });
          if (index === -1) return;
          const x = xAxis.getPixelForValue(index);
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x, yAxis.top);
          ctx.lineTo(x, yAxis.bottom);
          ctx.lineWidth = 2;
          ctx.strokeStyle = '#f44336'; // red for period day 1
          ctx.stroke();
          ctx.restore();
        }

        function drawOvLine(date) {
          const index = labels.findIndex(label => {
            const dt = new Date(date);
            return dt.toLocaleDateString('en-GB', {day:'numeric', month:'short'}) === label;
          });
          if (index === -1) return;
          const x = xAxis.getPixelForValue(index);
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x, yAxis.top);
          ctx.lineTo(x, yAxis.bottom);
          ctx.lineWidth = 2;
          ctx.strokeStyle = '#ffca28'; // amber for ovulation day
          ctx.stroke();
          ctx.restore();
        }

        periodMarkers.forEach(drawLine);
        ovulationMarkers.forEach(drawOvLine);
      }
    };

    window.bbtChartInstance = new Chart(document.getElementById('bbtChart'), {
      type: 'line',
      data: {
        labels: labels.length ? labels : ['No Data'],
        datasets: [{
          label: 'BBT',
          data: dataPoints.length ? dataPoints : [null],
          borderColor: 'purple',
          fill: false,
          tension: 0.1,
          pointRadius: 3,
          pointHoverRadius: 6,
        }]
      },
      options: {
        responsive: true,
        scales: {
          y: {
            title: { display: true, text: 'Temperature (¬∞C)' },
            suggestedMin: 35,
            suggestedMax: 38
          },
          x: {
            title: { display: true, text: 'Date' }
          }
        }
      },
      plugins: [verticalLinePlugin]
    });

    // CM chart (average per cycle)
    const cmTypes = ['dry', 'sticky', 'creamy', 'watery', 'egg white'];
    const cmTypeCounts = {};
    cmTypes.forEach(t => cmTypeCounts[t] = 0);
    let totalCycles = cycles.length;

    cycles.forEach(cycle => {
      const uniqueCycleEntries = uniquePerDay(cycle);
      const seenTypes = new Set();
      uniqueCycleEntries.forEach(e => {
        const cm = (e.cm || '').toLowerCase();
        if (cmTypes.includes(cm)) seenTypes.add(cm);
      });
      seenTypes.forEach(t => cmTypeCounts[t]++);
    });

    const cmLabels = ['Dry', 'Sticky', 'Creamy', 'Watery', 'Egg White'];
    const cmData = cmLabels.map(label => {
      const key = label.toLowerCase();
      return totalCycles ? (cmTypeCounts[key] / totalCycles).toFixed(2) : 0;
    });

    if(window.cmChartInstance) window.cmChartInstance.destroy();

    window.cmChartInstance = new Chart(document.getElementById('cmChart'), {
      type: 'bar',
      data: {
        labels: cmLabels,
        datasets: [{
          label: 'Average CM Occurrence per Cycle',
          data: cmData,
          backgroundColor: ['#fde2e4', '#fad2e1', '#dfe7fd', '#cdeac0', '#b5ead7']
        }]
      },
      options: {
        responsive: true,
        scales: {
          y: {
            beginAtZero: true,
            title: { display: true, text: 'Avg Occurrence per Cycle' }
          }
        }
      }
    });

    // Symptoms average per cycle
    const symptomsAvg = { cramps: 0, spotting: 0, breast: 0, digestive: 0 };
    cycles.forEach(cycle => {
      const uniqueCycleEntries = uniquePerDay(cycle);
      symptomsAvg.cramps += uniqueCycleEntries.filter(e => (e.cramps || '').toLowerCase() !== 'none').length / uniqueCycleEntries.length;
      symptomsAvg.spotting += uniqueCycleEntries.filter(e => (e.spotting || '').toLowerCase() !== 'none').length / uniqueCycleEntries.length;
      symptomsAvg.breast += uniqueCycleEntries.filter(e => (e.breastChanges || '').toLowerCase() !== 'none').length / uniqueCycleEntries.length;
      symptomsAvg.digestive += uniqueCycleEntries.filter(e => (e.digestive || '').toLowerCase() !== 'none').length / uniqueCycleEntries.length;
    });

    // Average them by cycle count
    Object.keys(symptomsAvg).forEach(k => symptomsAvg[k] = totalCycles ? (symptomsAvg[k] / totalCycles) : 0);

    if(window.symptomsChartInstance) window.symptomsChartInstance.destroy();

    window.symptomsChartInstance = new Chart(document.getElementById('symptomsChart'), {
      type: 'bar',
      data: {
        labels: ['Cramps', 'Spotting', 'Breast Changes', 'Digestive'],
        datasets: [{
          label: 'Average Occurrence per Cycle',
          data: [symptomsAvg.cramps, symptomsAvg.spotting, symptomsAvg.breast, symptomsAvg.digestive],
          backgroundColor: ['#f28e8e', '#f2c28e', '#a8d0e6', '#c3aed6']
        }]
      },
      options: { responsive: true }
    });

    // Mood timeline (all entries)
    const knownMoods = ['Calm', 'Happy', 'Irritable', 'Low'];
    const moodColors = { Happy: '#ffd700', Calm: '#87cefa', Low: '#ff6b6b', Irritable: '#ffa07a' };
    const moodFreq = {};
    knownMoods.forEach(m => moodFreq[m] = 0);
    allEntries.forEach(e => {
      const mood = (e.mood || '').trim();
      if (knownMoods.includes(mood)) moodFreq[mood]++;
    });

    const moodLabels = knownMoods;
    const moodData = moodLabels.map(m => moodFreq[m]);
    const moodBarColors = moodLabels.map(m => moodColors[m] || '#ccc');

    if(window.moodChartInstance) window.moodChartInstance.destroy();

    window.moodChartInstance = new Chart(document.getElementById('moodChart'), {
      type: 'bar',
      data: {
        labels: moodLabels,
        datasets: [{
          label: 'Mood Frequency (All Time)',
          data: moodData,
          backgroundColor: moodBarColors
        }]
      },
      options: {
        responsive: true,
        scales: {
          y: { beginAtZero: true, title: { display: true, text: 'Number of Entries' } },
          x: { title: { display: true, text: 'Mood Type' } }
        }
      }
    });
  }

</script>

<script>
  function changeMonth(offset) {
    const newDate = new Date(viewYear, viewMonth + offset);
    viewMonth = newDate.getMonth();
    viewYear = newDate.getFullYear();
    renderCalendar(viewMonth, viewYear);
    renderCharts(groupCycles(allEntries));
  }
</script>

<script>
  // Initial load (auth handled earlier)
  auth.onAuthStateChanged(user => {
    if (!user) {
      window.location.href = "index.html";
      return;
    }
  });
</script>

<script>
  // Run logic after auth and data load
  auth.onAuthStateChanged(user => {
    if (!user) return;
    (async () => {
      try {
        // Legacy entries
        const legacySnapshot = await db.collection("entries")
          .where("uid", "==", user.uid)
          .orderBy("entryDate")
          .get();
        const legacyEntries = legacySnapshot.docs.map(doc => doc.data());

        // User-scoped entries
        const userSnapshot = await db.collection("users")
          .doc(user.uid)
          .collection("entries")
          .orderBy("entryDate")
          .get();
        const userEntries = userSnapshot.docs.map(doc => doc.data());

        allEntries = [...legacyEntries, ...userEntries];
        allEntries.sort((a,b) => new Date(a.entryDate) - new Date(b.entryDate));

        runLogic();
      } catch (e) {
        console.error("Error loading entries", e);
      }
    })();
  });
</script>

</body>
</html>
