function renderCharts(cycle) {
  const cmTypes = ['dry', 'sticky', 'creamy', 'watery', 'egg white'];

  const bbtData = cycle.filter(e => e.bbt && !isNaN(parseFloat(e.bbt)));
  const lhData = cycle.filter(e => e.opk && !isNaN(parseFloat(e.opk)));

  const allLabels = [...new Set([...bbtData, ...lhData].map(e => formatDate(e.entryDate)))].sort();

  if (bbtChartInstance) bbtChartInstance.destroy();
  bbtChartInstance = new Chart(document.getElementById("bbtChart"), {
    type: 'line',
    data: {
      labels: allLabels,
      datasets: [
        {
          label: 'BBT',
          data: allLabels.map(d => {
            const entry = bbtData.find(e => formatDate(e.entryDate) === d);
            return entry ? parseFloat(entry.bbt) : null;
          }),
          borderColor: 'purple',
          yAxisID: 'y-bbt',
          spanGaps: true
        },
        {
          label: 'LH (OPK)',
          data: allLabels.map(d => {
            const entry = lhData.find(e => formatDate(e.entryDate) === d);
            return entry ? parseFloat(entry.opk) : null;
          }),
          borderColor: 'orange',
          borderDash: [4, 2],
          yAxisID: 'y-opk',
          spanGaps: true
        }
      ]
    },
    options: {
      responsive: true,
      interaction: {
        mode: 'index',
        intersect: false
      },
      scales: {
        'y-bbt': {
          position: 'left',
          min: 35.5,
          max: 37.5,
          title: {
            display: true,
            text: 'BBT (Â°C)'
          }
        },
        'y-opk': {
          position: 'right',
          min: 0,
          max: 2,
          grid: {
            drawOnChartArea: false
          },
          title: {
            display: true,
            text: 'LH (OPK)'
          }
        }
      },
      plugins: {
        legend: {
          position: 'top'
        }
      }
    }
  });

  // CM Chart (unchanged)
  const cmCounts = cmTypes.reduce((acc, type) => {
    acc[type] = 0;
    return acc;
  }, {});
  cycle.forEach(e => {
    const cm = (e.cm || '').toLowerCase();
    if (cmTypes.includes(cm)) cmCounts[cm]++;
  });

  if (cmChartInstance) cmChartInstance.destroy();
  cmChartInstance = new Chart(document.getElementById("cmChart"), {
    type: 'bar',
    data: {
      labels: cmTypes,
      datasets: [{
        label: 'CM Entries',
        data: cmTypes.map(type => cmCounts[type]),
        backgroundColor: '#8ecae6'
      }]
    },
    options: {
      responsive: true,
      scales: { y: { beginAtZero: true } }
    }
  });

  // Symptom Chart (unchanged)
  const symptomCounts = {
    Cramps: 0,
    Spotting: 0,
    'Breast Changes': 0,
    Digestive: 0
  };
  cycle.forEach(e => {
    if (e.cramps && e.cramps.toLowerCase() !== 'none') symptomCounts['Cramps']++;
    if (e.spotting && e.spotting.toLowerCase() !== 'none') symptomCounts['Spotting']++;
    if (e.breastChanges && e.breastChanges.toLowerCase() !== 'none') symptomCounts['Breast Changes']++;
    if (e.digestive && e.digestive.toLowerCase() !== 'none') symptomCounts['Digestive']++;
  });

  if (symptomsChartInstance) symptomsChartInstance.destroy();
  symptomsChartInstance = new Chart(document.getElementById("symptomsChart"), {
    type: 'bar',
    data: {
      labels: Object.keys(symptomCounts),
      datasets: [{
        label: 'Symptom Count',
        data: Object.values(symptomCounts),
        backgroundColor: ['#f28e8e', '#f2c28e', '#c3aed6', '#a0d9b4']
      }]
    },
    options: {
      responsive: true,
      scales: { y: { beginAtZero: true } }
    }
  });

  // Mood Chart (unchanged)
  const moodOptions = ['Calm', 'Happy', 'Irritable', 'Low'];
  const moodCounts = moodOptions.reduce((acc, mood) => {
    acc[mood] = 0;
    return acc;
  }, {});
  cycle.forEach(e => {
    const mood = (e.mood || '').trim();
    if (moodOptions.includes(mood)) moodCounts[mood]++;
  });

  if (moodChartInstance) moodChartInstance.destroy();
  moodChartInstance = new Chart(document.getElementById("moodChart"), {
    type: 'bar',
    data: {
      labels: moodOptions,
      datasets: [{
        label: 'Mood Entries',
        data: moodOptions.map(mood => moodCounts[mood]),
        backgroundColor: '#ffd166'
      }]
    },
    options: {
      responsive: true,
      scales: {
        y: { beginAtZero: true },
        x: {
          ticks: {
            autoSkip: false,
            maxRotation: 30,
            minRotation: 0
          }
        }
      }
    }
  });

  // Sex Chart (unchanged)
  const sex = cycle.filter(e => e.sex && e.sex.toLowerCase() === 'yes');
  if (sex.length) {
    const sexDates = sex.map(e => formatDate(e.entryDate));
    const counts = {};
    sexDates.forEach(d => counts[d] = (counts[d] || 0) + 1);
    if (sexChartInstance) sexChartInstance.destroy();
    sexChartInstance = new Chart(document.getElementById("sexChart"), {
      type: 'bar',
      data: {
        labels: Object.keys(counts),
        datasets: [{
          label: 'Sex',
          data: Object.values(counts),
          backgroundColor: '#f67280'
        }]
      },
      options: { responsive: true, scales: { y: { beginAtZero: true } } }
    });
  }
}
